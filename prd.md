MVP 1 Final Plan
1. User Roles & Screen Blueprints
üë®‚Äçüîß Staff User (Mobile App - Simplified to 2 Core Screens)
Screen 1: Main Dashboard & Clock In/Out

Purpose: A single screen for all primary actions: tracking time and viewing personal history.

UI Components:

Top Section: A large status indicator ("Clocked In" or "Clocked Out") and the Clock In/Out button. A dropdown to select a Job is required before clocking in.

Middle Section: KPI cards showing "Total Hours Today," "This Week," and "This Month."

Bottom Section (Drill-Down View): A list of all timesheet entries. Tapping a KPI card filters this list to the corresponding period (today, this week, this month). Tapping a specific timesheet entry opens a Map View Modal, showing the clock-in and clock-out locations as pins.

Backend Interactions:

RPC('get_timesheets_for_period', ...) to fetch data for the drill-down view.

INSERT into timesheets on clock-in.

Background Service: When clocked in, a service will periodically send location data to the location_pings table.

Screen 2: Settings

Purpose: Basic profile management.

UI Components: "Edit Profile," "Change Password," "Logout."

Backend Interactions: UPDATE on profiles table, Supabase Auth functions.

üëë Admin User (Web Dashboard & Mobile App)
Web Dashboard Tabs:

Tab 1: Live Dashboard & Map View

Purpose: Real-time operational command center.

UI Components:

Live Map: A large map component displaying the current location of all "Clocked In" staff as moving icons.

Live List: A list of active staff showing their name, current job, and running shift duration.

Drill-Down: Clicking on a staff member in the list or on the map zooms in on their location and shows their recent location history for the current shift.

Backend Interactions:

RPC('get_latest_locations', ...) to fetch the most recent ping for each active user.

Supabase Realtime subscription to the location_pings table to update the map without needing to refresh.

Tab 2: Timesheet & Payroll

Purpose: To review work history and calculate wages.

UI Components:

A powerful table of all company timesheets with filters for staff and date ranges.

A "Calculate Payroll" button.

A summary view showing each employee, their total hours in the period, their pay rate, and the calculated total wage.

Backend Interactions:

RPC('calculate_payroll_for_period', ...) is the core function for this screen.

Admins can drill down into any user's timesheets, same as the staff view.

Tab 3: Reports

Purpose: To view automated daily summaries.

UI Components: A view displaying historical reports. The primary report will be the "Daily Job Summary," showing:

Total hours logged yesterday.

Breakdown of hours per job.

List of all staff who worked.

Total calculated labor cost for the day.

Backend Interactions:

Data is generated by a daily scheduled Edge Function and stored, or generated on-the-fly by calling our aggregate RPCs with yesterday's date range.

Tab 4: Employees

Purpose: To manage staff, roles, and wages.

UI Components:

A list of all employees.

An "Edit" action for each employee that opens a form to set/update their Pay Rate and role.

Backend Interactions: UPDATE operations on the company_members table.

Tab 5: Job Management

Purpose: Standard CRUD for jobs (no change from the previous plan).

Admin Mobile App:

The admin mobile app will primarily feature a simplified version of the Live Dashboard & Map View, allowing them to see where their team is from their phone.

2. Technical Deep Dive: Required Updates
To support these new features, we must update our database schema and add new logic.

Database Schema Changes
Add Payroll Columns to company_members:

SQL

ALTER TABLE public.company_members
ADD COLUMN pay_rate NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
ADD COLUMN pay_period TEXT NOT NULL DEFAULT 'hourly' CHECK (pay_period IN ('hourly'));
Create New location_pings Table:

SQL

CREATE TABLE public.location_pings (
  id            BIGSERIAL PRIMARY KEY,
  user_id       UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  timesheet_id  UUID NOT NULL REFERENCES public.timesheets(id) ON DELETE CASCADE,
  latitude      DOUBLE PRECISION NOT NULL,
  longitude     DOUBLE PRECISION NOT NULL,
  created_at    TIMESTAMPTZ DEFAULT NOW()
);
-- Create an index for faster lookups of recent locations
CREATE INDEX idx_location_pings_user_timestamp ON public.location_pings (user_id, created_at DESC);
New Database & Edge Functions
calculate_payroll_for_period (PostgreSQL Function):

Logic: This function will join timesheets with company_members. For each staff member, it will sum their work duration (in hours) and multiply it by their stored pay_rate.

Returns: A table with staff_id, full_name, total_hours, pay_rate, and total_wage.

get_latest_locations (PostgreSQL Function):

Logic: For a given company, this function will find all currently clocked-in users and retrieve only the most recent record for each from the location_pings table.

Returns: A table with user_id, full_name, latitude, longitude, and last_updated_at.

daily_report_generator (Supabase Edge Function):

Trigger: Runs on a daily cron schedule (e.g., every morning at 6 AM).

Logic:

Calls calculate_payroll_for_period for the previous day.

Formats the results into an HTML email.

Uses an email service provider (e.g., Resend) to send the report to all users with the 'admin' role in the company.







based on all chat we had, create the final downloadable file with each and every single deytail we need, so we can simply copy paste



Show thinking
Of course. Here is the final, consolidated build plan for Project Momentum.

This document contains all the necessary SQL schemas, database functions, architectural plans, screen blueprints, and the sprint schedule. It is designed to be the single source of truth for the development team.

You can save this content as a markdown file (e.g., PROJECT_MOMENTUM_BUILD_PLAN.md).

üöÄ Project Momentum - Final Build Plan
Objective: Develop a robust, multi-tenant workforce management MVP with time tracking, live location monitoring, and payroll calculation.

Timeline: 5-Day Intensive Sprint.

Version: 1.0

Date: 28 September 2025

üèóÔ∏è Section 1: Core Architecture
Tech Stack
Backend-as-a-Service: Supabase (PostgreSQL, Auth, Realtime, Edge Functions)

Web Dashboard: Next.js (React)

Mobile App: Expo

Email Service: Resend (or SendGrid/Postmark)

Repository Strategy: Monorepo
We will use a monorepo managed by pnpm to ensure code consistency and atomic commits.

Directory Structure:

/momentum-monorepo/
‚îú‚îÄ‚îÄ apps/
‚îÇ   ‚îú‚îÄ‚îÄ mobile/         # expo
‚îÇ   ‚îî‚îÄ‚îÄ web/            # Next.js web dashboard
‚îú‚îÄ‚îÄ packages/
‚îÇ   ‚îú‚îÄ‚îÄ db/             # All .sql files for Supabase migrations
‚îÇ   ‚îî‚îÄ‚îÄ shared-types/   # Shared TypeScript types
‚îî‚îÄ‚îÄ pnpm-workspace.yaml
‚îî‚îÄ‚îÄ package.json
üíæ Section 2: Database Schema (DDL)
This is the complete SQL script to set up all tables and security policies. Run this in the Supabase SQL Editor.

SQL

-- ========= MOMENTUM PRJ: COMPLETE SCHEMA =========

-- 1. COMPANIES TABLE
CREATE TABLE public.companies (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name          TEXT NOT NULL,
  created_at    TIMESTAMPTZ DEFAULT NOW()
);
COMMENT ON TABLE public.companies IS 'Represents a business/tenant in the system.';

-- 2. PROFILES TABLE (Stores user-centric info)
CREATE TABLE public.profiles (
  id          UUID NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name   TEXT
);
COMMENT ON TABLE public.profiles IS 'Stores user-specific data, independent of company membership.';

-- 3. COMPANY MEMBERS JUNCTION TABLE (Many-to-Many link)
CREATE TABLE public.company_members (
  user_id     UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  company_id  UUID NOT NULL REFERENCES public.companies(id) ON DELETE CASCADE,
  role        TEXT NOT NULL CHECK (role IN ('admin', 'staff')),
  pay_rate    NUMERIC(10, 2) NOT NULL DEFAULT 0.00,
  pay_period  TEXT NOT NULL DEFAULT 'hourly' CHECK (pay_period IN ('hourly')),
  PRIMARY KEY (user_id, company_id)
);
COMMENT ON TABLE public.company_members IS 'Links users to companies and defines their role and pay rate.';

-- 4. JOBS TABLE
CREATE TABLE public.jobs (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name          TEXT NOT NULL,
  address       TEXT,
  company_id    UUID NOT NULL REFERENCES public.companies(id) ON DELETE CASCADE,
  is_archived   BOOLEAN DEFAULT FALSE
);
COMMENT ON TABLE public.jobs IS 'Defines a work site or project.';

-- 5. TIMESHEETS TABLE
CREATE TABLE public.timesheets (
  id                    UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  staff_id              UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  job_id                UUID NOT NULL REFERENCES public.jobs(id) ON DELETE CASCADE,
  company_id            UUID NOT NULL REFERENCES public.companies(id) ON DELETE CASCADE,
  clock_in              TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  clock_out             TIMESTAMPTZ,
  clock_in_latitude     DOUBLE PRECISION,
  clock_in_longitude    DOUBLE PRECISION,
  clock_out_latitude    DOUBLE PRECISION,
  clock_out_longitude   DOUBLE PRECISION
);
COMMENT ON TABLE public.timesheets IS 'Individual time entries for staff against jobs.';

-- 6. LOCATION PINGS TABLE (For live tracking)
CREATE TABLE public.location_pings (
  id            BIGSERIAL PRIMARY KEY,
  user_id       UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  timesheet_id  UUID NOT NULL REFERENCES public.timesheets(id) ON DELETE CASCADE,
  latitude      DOUBLE PRECISION NOT NULL,
  longitude     DOUBLE PRECISION NOT NULL,
  created_at    TIMESTAMPTZ DEFAULT NOW()
);
COMMENT ON TABLE public.location_pings IS 'Stores periodic location updates for live tracking.';
CREATE INDEX idx_location_pings_user_timestamp ON public.location_pings (user_id, created_at DESC);

-- ========= ROW LEVEL SECURITY (RLS) POLICIES =========

-- Enable RLS on all tables
ALTER TABLE public.companies ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.company_members ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.jobs ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.timesheets ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.location_pings ENABLE ROW LEVEL SECURITY;

-- Policy: Allow users to see and manage their own profile
CREATE POLICY "Allow users to manage their own profile" ON public.profiles
  FOR ALL USING (auth.uid() = id);

-- Policy: Allow members to see companies they belong to
CREATE POLICY "Allow members to see their own companies" ON public.companies
  FOR SELECT USING (EXISTS (
    SELECT 1 FROM public.company_members
    WHERE company_members.company_id = id AND company_members.user_id = auth.uid()
  ));

-- Policy: Allow members to see their own membership details
CREATE POLICY "Allow users to see their own memberships" ON public.company_members
  FOR SELECT USING (auth.uid() = user_id);

-- Policy: Allow admins to manage memberships in their company
CREATE POLICY "Allow admins to manage company memberships" ON public.company_members
  FOR ALL USING (EXISTS (
    SELECT 1 FROM public.company_members cm
    WHERE cm.company_id = company_members.company_id AND cm.user_id = auth.uid() AND cm.role = 'admin'
  ));

-- Create similar RLS policies for jobs, timesheets, and location_pings
-- Example for timesheets:
CREATE POLICY "Allow staff to manage their own timesheets" ON public.timesheets
  FOR ALL USING (auth.uid() = staff_id);
CREATE POLICY "Allow admins to see all company timesheets" ON public.timesheets
  FOR SELECT USING (EXISTS (
    SELECT 1 FROM public.company_members cm
    WHERE cm.company_id = timesheets.company_id AND cm.user_id = auth.uid() AND cm.role = 'admin'
  ));

üß† Section 3: Database Logic (Functions & RPCs)
Run this SQL to create all the necessary PostgreSQL functions.

SQL

-- ========= CORE LOGIC FUNCTIONS =========

CREATE OR REPLACE FUNCTION public.get_active_shift(p_staff_id UUID)
RETURNS SETOF public.timesheets AS $$
  SELECT * FROM public.timesheets
  WHERE staff_id = p_staff_id AND clock_out IS NULL LIMIT 1;
$$ LANGUAGE sql STABLE;

CREATE OR REPLACE FUNCTION public.clock_out_user(p_timesheet_id UUID, p_latitude DOUBLE PRECISION, p_longitude DOUBLE PRECISION)
RETURNS VOID AS $$
  UPDATE public.timesheets
  SET
    clock_out = NOW(),
    clock_out_latitude = p_latitude,
    clock_out_longitude = p_longitude
  WHERE id = p_timesheet_id AND staff_id = auth.uid();
$$ LANGUAGE sql SECURITY DEFINER;

-- ========= DASHBOARD & ANALYTICS FUNCTIONS =========

CREATE OR REPLACE FUNCTION public.get_timesheets_for_period(p_staff_id UUID, p_start_date TIMESTAMPTZ, p_end_date TIMESTAMPTZ)
RETURNS TABLE (
  id UUID,
  job_name TEXT,
  clock_in TIMESTAMPTZ,
  clock_out TIMESTAMPTZ,
  duration INTERVAL,
  clock_in_latitude DOUBLE PRECISION,
  clock_in_longitude DOUBLE PRECISION,
  clock_out_latitude DOUBLE PRECISION,
  clock_out_longitude DOUBLE PRECISION
) AS $$
  SELECT
    t.id,
    j.name as job_name,
    t.clock_in,
    t.clock_out,
    (COALESCE(t.clock_out, NOW()) - t.clock_in) as duration,
    t.clock_in_latitude,
    t.clock_in_longitude,
    t.clock_out_latitude,
    t.clock_out_longitude
  FROM public.timesheets t
  JOIN public.jobs j ON t.job_id = j.id
  WHERE t.staff_id = p_staff_id
    AND t.clock_in >= p_start_date
    AND t.clock_in <= p_end_date
  ORDER BY t.clock_in DESC;
$$ LANGUAGE sql STABLE;

CREATE OR REPLACE FUNCTION public.get_latest_locations(p_company_id UUID)
RETURNS TABLE (
  user_id UUID,
  full_name TEXT,
  latitude DOUBLE PRECISION,
  longitude DOUBLE PRECISION,
  last_updated_at TIMESTAMPTZ
) AS $$
  SELECT DISTINCT ON (p.user_id)
    p.user_id,
    pr.full_name,
    p.latitude,
    p.longitude,
    p.created_at as last_updated_at
  FROM public.location_pings p
  JOIN public.profiles pr ON p.user_id = pr.id
  WHERE p.timesheet_id IN (
      SELECT id FROM public.timesheets
      WHERE company_id = p_company_id AND clock_out IS NULL
    )
  ORDER BY p.user_id, p.created_at DESC;
$$ LANGUAGE sql STABLE;

-- ========= PAYROLL & REPORTING FUNCTIONS =========

CREATE OR REPLACE FUNCTION public.calculate_payroll_for_period(p_company_id UUID, p_start_date TIMESTAMPTZ, p_end_date TIMESTAMPTZ)
RETURNS TABLE (
  staff_id UUID,
  full_name TEXT,
  total_hours NUMERIC,
  pay_rate NUMERIC,
  total_wage NUMERIC
) AS $$
  SELECT
    cm.user_id as staff_id,
    p.full_name,
    -- Extract epoch, divide by 3600 to get hours as a numeric value
    SUM(EXTRACT(EPOCH FROM (COALESCE(t.clock_out, t.clock_in) - t.clock_in))) / 3600.0 AS total_hours,
    cm.pay_rate,
    (SUM(EXTRACT(EPOCH FROM (COALESCE(t.clock_out, t.clock_in) - t.clock_in))) / 3600.0) * cm.pay_rate AS total_wage
  FROM public.timesheets t
  JOIN public.company_members cm ON t.staff_id = cm.user_id AND t.company_id = cm.company_id
  JOIN public.profiles p ON t.staff_id = p.id
  WHERE t.company_id = p_company_id
    AND t.clock_in >= p_start_date
    AND t.clock_in <= p_end_date
  GROUP BY cm.user_id, p.full_name, cm.pay_rate;
$$ LANGUAGE sql STABLE;

‚ö° Section 4: Edge Functions & Scheduled Jobs
Create a Supabase Edge Function for daily email reports.

File: supabase/functions/daily-report/index.ts
Cron Schedule: 0 6 * * * (Runs at 6 AM daily)

TypeScript

// supabase/functions/daily-report/index.ts
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { createClient } from "https://esm.sh/@supabase/supabase-js@2.0.0";

serve(async (_req) => {
  try {
    const supabaseClient = createClient(
      Deno.env.get("SUPABASE_URL") ?? "",
      Deno.env.get("SUPABASE_SERVICE_ROLE_KEY") ?? ""
    );

    // 1. Get all companies
    const { data: companies } = await supabaseClient.from("companies").select("id, name");

    for (const company of companies) {
      // 2. Get admins for the company
      const { data: admins } = await supabaseClient
        .from("company_members")
        .select("profiles(id, full_name, users(email))")
        .eq("company_id", company.id)
        .eq("role", "admin");
      
      const adminEmails = admins.map(a => a.profiles.users.email);
      if (adminEmails.length === 0) continue;

      // 3. Calculate yesterday's payroll
      const yesterdayStart = new Date();
      yesterdayStart.setDate(yesterdayStart.getDate() - 1);
      yesterdayStart.setHours(0, 0, 0, 0);

      const yesterdayEnd = new Date();
      yesterdayEnd.setDate(yesterdayEnd.getDate() - 1);
      yesterdayEnd.setHours(23, 59, 59, 999);

      const { data: reportData } = await supabaseClient.rpc("calculate_payroll_for_period", {
          p_company_id: company.id,
          p_start_date: yesterdayStart.toISOString(),
          p_end_date: yesterdayEnd.toISOString(),
        });

      // 4. Format and send email using Resend
      const emailHtml = `<h1>Daily Report for ${company.name}</h1>...`; // Format reportData into HTML
      
      await fetch("https://api.resend.com/emails", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${Deno.env.get("RESEND_API_KEY")}`,
        },
        body: JSON.stringify({
          from: "reports@momentum.app",
          to: adminEmails,
          subject: `Momentum Daily Report: ${yesterdayStart.toDateString()}`,
          html: emailHtml,
        }),
      });
    }

    return new Response("Reports sent", { status: 200 });
  } catch (error) {
    return new Response(`Error: ${error.message}`, { status: 500 });
  }
});
üì± Section 5: Screen & Feature Blueprint
This is the guide for frontend developers, mapping UI components to specific backend calls.

Staff Mobile App
Screen: Main Dashboard

KPI Cards (Today, Week, Month): Call rpc('get_timesheets_for_period', ...) with different date ranges and sum the durations on the client.

Timesheet List: Display the results from the get_timesheets_for_period RPC.

Clock In Button:

Get GPS location.

supabase.from('timesheets').insert({ staff_id, job_id, company_id, clock_in_latitude, ... })

Start background location service.

Clock Out Button:

Get GPS location.

supabase.rpc('clock_out_user', { p_timesheet_id, p_latitude, ... })

Stop background location service.

Background Service (while clocked in):

Every 5 minutes, get GPS location.

supabase.from('location_pings').insert({ user_id, timesheet_id, latitude, ... })

Admin Web Dashboard
Tab: Live Dashboard & Map

Map Component: On load, call supabase.rpc('get_latest_locations', { p_company_id }) and render pins.

Real-time Updates: Create a Supabase Realtime subscription: supabase.channel('live_locations').on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'location_pings' }, payload => { // update map marker for payload.new.user_id }).

Tab: Timesheet & Payroll

Date Range Selector: User selects start and end dates.

"Calculate Payroll" Button: On click, call supabase.rpc('calculate_payroll_for_period', { p_company_id, p_start_date, p_end_date }).

Payroll Table: Render the results from the RPC call.

Tab: Employees

Employee List: supabase.from('company_members').select('role, pay_rate, profiles(full_name))').eq('company_id', p_company_id)

Edit Pay Rate Form: On save, supabase.from('company_members').update({ pay_rate: ... }).match({ user_id, company_id })

üóìÔ∏è Section 6: The 5-Day Sprint Plan
Day 1: Foundation

[AM] Set up the pnpm monorepo.

[AM] Create the Supabase project. Run the entire Schema SQL script.

[PM] Run the entire Functions SQL script.

[PM] Connect the Next.js and expo boilerplates to the Supabase instance. Implement Login/Logout and the Company Selection screen.

Day 2: Core Logic & Payroll

[AM] expo: Implement the staff dashboard UI and the Clock In/Out logic.

[PM] Next.js: Build the "Employees" tab to allow admins to set pay rates.

[PM] Next.js: Build the "Timesheet & Payroll" tab and wire it up to the calculate_payroll_for_period function.

Day 3: Live Tracking

[AM] Fluttexpor: Implement the background location service that sends data to the location_pings table.

[PM] Next.js: Build the "Live Dashboard" tab. Add a map component (Mapbox/Google Maps).

[PM] Next.js: Wire up the get_latest_locations RPC and the Supabase Realtime subscription to display and move markers on the map.

Day 4: Dashboards & Reporting

[AM] expo: Implement the KPI cards and the drill-down functionality on the staff dashboard.

[PM] Supabase: Write and deploy the daily-report Edge Function. Configure environment variables (API keys) and set the cron schedule.

[PM] Next.js: Build the "Reports" tab to show historical data.

Day 5: Integration, Testing & Polish

[AM] End-to-end testing of the entire user flow: Admin invites Staff -> Staff signs up -> Admin sets pay rate -> Staff clocks in -> Admin sees live location -> Staff clocks out -> Admin calculates payroll.

[PM] UI/UX polishing, bug fixing, and final preparations for deployment.